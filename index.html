<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VOICE TO PUMP.FUN COIN</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <script type="module">
    import { VersionedTransaction, Connection, Keypair } from 'https://cdn.skypack.dev/@solana/web3.js';
    import bs58 from 'https://cdn.skypack.dev/bs58';

    const RPC_ENDPOINT = "https://api.mainnet-beta.solana.com/";
    const web3Connection = new Connection(RPC_ENDPOINT, 'confirmed');

    window.sendLocalCreateTx = async (coinName, ticker, imageFile) => {
  const formData = new FormData();
  formData.append("file", imageFile);
  formData.append("name", coinName);
  formData.append("symbol", ticker);
  formData.append("description", "This is a test token");
  formData.append("twitter", "https://x.com/ponchokings3");
  formData.append("telegram", "");
  formData.append("website", "https://www.youtube.com/");
  formData.append("showName", "true");

  const metadataResponse = await fetch("https://pump.fun/api/ipfs", {
    method: "POST",
    body: formData,
  });

  const metadataResponseJSON = await metadataResponse.json();

  const mintKeypair = window.solanaWeb3.Keypair.generate();
  const mintPubkey = mintKeypair.publicKey.toBase58();

  const response = await fetch("http://localhost:3001/api/create-token", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      mintPubkey,
      name: metadataResponseJSON.metadata.name,
      symbol: metadataResponseJSON.metadata.symbol,
      uri: metadataResponseJSON.metadataUri
    }),
  });

  if (response.ok) {
    const result = await response.json();
    window.open(`https://pump.fun/coin/${mintPubkey}`, '_blank');
  } else {
    console.error("Token creation failed:", await response.text());
  }
};

  </script>
  <style>
    :root {
      --primary: #4ade80;
      --background: #121212;
      --foreground: #e0e0e0;
      --muted-bg: #1e1e1e;
      --error: #f87171;
    }

    body {
      margin: 0;
      font-family: 'Inter', sans-serif;
      background-color: var(--background);
      color: var(--foreground);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }

    .container {
      max-width: 600px;
      width: 100%;
    }

    h2 {
      margin-bottom: 1rem;
      color: var(--primary);
    }

    #info-box {
      background: var(--muted-bg);
      padding: 2rem;
      border-radius: 12px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    #info-box p {
      margin: 0.75rem 0;
      font-size: 1rem;
    }

    .label {
      font-weight: 600;
      color: #ffffffcc;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      margin: 0.5rem;
      border-radius: 8px;
      background: transparent;
      border: 1px solid var(--primary);
      color: var(--primary);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background-color: rgba(74, 222, 128, 0.15);
    }

    .btn.recording {
      border-color: var(--error);
      color: var(--error);
    }

    #mic-bar {
      display: flex;
      gap: 2px;
      height: 20px;
      justify-content: center;
      margin-top: 2rem;
    }

    .bar {
      width: 4px;
      height: 20%;
      background: #333;
      transition: height 0.1s;
    }

    .bar.active {
      background: orange;
    }

    #live-transcript-box {
      margin-top: 2rem;
      text-align: center;
      padding: 1rem 2rem;
      background: var(--muted-bg);
      border: 1px solid #333;
      border-radius: 10px;
    }

    #mic-status {
      font-weight: 600;
      color: var(--error);
      margin-bottom: 0.5rem;
    }

    #live-text {
      font-style: italic;
      color: #aaa;
    }

    #upload-btn {
    margin-top: 2rem;
    padding: 0.75rem 1.5rem;
    font-size: 1.1rem;
    border-radius: 10px;
    border: 2px solid var(--primary);
    background: transparent;
    color: var(--primary);
    cursor: not-allowed;
    opacity: 0.5;
    transition: all 0.3s ease;
  }

  #upload-btn.enabled {
    cursor: pointer;
    opacity: 1;
  }

  #upload-btn.enabled:hover {
    background-color: rgba(74, 222, 128, 0.15);
  }

  #upload-btn.uploading {
    background-color: var(--error);
    color: white;
    cursor: not-allowed;
    opacity: 1;
  }

    input[type="file"] {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>VOICE TO PUMP.FUN COIN</h2>

    <div id="info-box">
      <p><span class="label">Ticker:</span> <span id="ticker-text">N/A</span></p>
      <p><span class="label">Coin Name:</span> <span id="coin-text">N/A</span></p>
      <p><span class="label">Image:</span> <span id="image-text">N/A</span></p>
    </div>

    <div>
      <button class="btn" id="ticker-btn">SAY TICKER</button>
      <button class="btn" id="coin-btn">SAY COIN NAME</button>
      <button class="btn" id="image-btn">SELECT IMAGE</button>
      <input type="file" id="image-input" accept="image/*" />
    </div>

    <div id="mic-bar"></div>

    <div id="live-transcript-box">
      <p id="mic-status">MIC DISABLED</p>
      <p><strong>Live transcript:</strong></p>
      <p id="live-text">...</p>
    </div>

    <button id="upload-btn">FILL IN THE FIELDS TO UPLOAD</button>
  </div>

  <script>
    const tickerText = document.getElementById('ticker-text');
    const coinText = document.getElementById('coin-text');
    const imageText = document.getElementById('image-text');
    const tickerBtn = document.getElementById('ticker-btn');
    const coinBtn = document.getElementById('coin-btn');
    const imageBtn = document.getElementById('image-btn');
    const imageInput = document.getElementById('image-input');
    const micBar = document.getElementById('mic-bar');
    const micStatus = document.getElementById('mic-status');
    const liveText = document.getElementById('live-text');
    const uploadBtn = document.getElementById('upload-btn');

    let recognition, activeBtn = null, listeningFor = null;
    let isRecording = false;
    let finalTranscript = '';

    const bars = [];
    for (let i = 0; i < 40; i++) {
      const bar = document.createElement('div');
      bar.classList.add('bar');
      micBar.appendChild(bar);
      bars.push(bar);
    }

    let audioContext, analyser, micStream, dataArray;

    async function setupAudioMeter() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioContext.createMediaStreamSource(micStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
      }
    }

    function animateMicLevel(level) {
      bars.forEach((bar, i) => {
        if (i < level) {
          bar.classList.add('active');
          bar.style.height = `${Math.random() * 80 + 20}%`;
        } else {
          bar.classList.remove('active');
          bar.style.height = '20%';
        }
      });
    }

    function updateMicLevel() {
      if (!analyser || !isRecording) return;
      analyser.getByteFrequencyData(dataArray);
      const avg = dataArray.reduce((sum, val) => sum + val, 0) / dataArray.length;
      const level = Math.floor((avg / 255) * bars.length);
      animateMicLevel(level);
      if (isRecording) requestAnimationFrame(updateMicLevel);
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.interimResults = true;
      recognition.continuous = true;

      recognition.onresult = (event) => {
        let interimTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          const transcript = event.results[i][0].transcript.trim();
          if (event.results[i].isFinal) {
            finalTranscript += transcript + ' ';
          } else {
            interimTranscript += transcript;
          }
        }
        liveText.textContent = finalTranscript + interimTranscript;
      };

      recognition.onend = () => {
        const result = finalTranscript.trim();
        if (listeningFor === 'ticker') {
          tickerText.textContent = result.split(' ')[0] || 'N/A';
        } else if (listeningFor === 'coin') {
          if (result.length > 32) {
            coinText.textContent = result.slice(0, 32) + ' (shortened to 32 characters)';
          } else {
            coinText.textContent = result || 'N/A';
          }
        }
        stopRecording();
      };

      recognition.onerror = (event) => {
        console.error('Recognition error:', event.error);
        stopRecording();
      };
    } else {
      alert('Speech Recognition not supported. Try Chrome.');
    }

    async function startRecording(forWhat) {
      if (!recognition) return;
      finalTranscript = '';
      listeningFor = forWhat;
      await setupAudioMeter();
      recognition.start();
      isRecording = true;
      updateMicLevel();
      const btn = forWhat === 'ticker' ? tickerBtn : coinBtn;
      activeBtn = btn;
      btn.textContent = 'CLICK TO STOP';
      btn.classList.add('recording');
      micStatus.textContent = 'MIC ENABLED';
      micStatus.style.color = '#0f0';
      liveText.textContent = '...';
    }

    function stopRecording() {
      if (!recognition) return;
      recognition.stop();
      isRecording = false;
      animateMicLevel(0);
      if (activeBtn) {
        activeBtn.textContent = activeBtn.id === 'ticker-btn' ? 'SAY TICKER' : 'SAY COIN NAME';
        activeBtn.classList.remove('recording');
        activeBtn = null;
      }
      micStatus.textContent = 'MIC DISABLED';
      micStatus.style.color = '#f00';
      liveText.textContent = '...';
      checkFields();
    }

    tickerBtn.addEventListener('click', () => {
      if (isRecording && listeningFor === 'ticker') {
        stopRecording();
      } else {
        stopRecording();
        startRecording('ticker');
      }
    });

    coinBtn.addEventListener('click', () => {
      if (isRecording && listeningFor === 'coin') {
        stopRecording();
      } else {
        stopRecording();
        startRecording('coin');
      }
    });

    imageBtn.addEventListener('click', () => {
      imageInput.click();
    });

    imageInput.addEventListener('change', () => {
      const file = imageInput.files[0];
      imageText.textContent = file ? file.name : 'N/A';
      checkFields();
    });

    function checkFields() {
      const coin = coinText.textContent;
      const ticker = tickerText.textContent;
      const image = imageInput.files[0];
      const valid = coin !== 'N/A' && ticker !== 'N/A' && image;

      if (valid) {
        uploadBtn.textContent = 'UPLOAD TO PUMP.FUN';
        uploadBtn.classList.add('enabled');
        uploadBtn.disabled = false;
      } else {
        uploadBtn.textContent = 'FILL IN THE FIELDS TO UPLOAD';
        uploadBtn.classList.remove('enabled');
        uploadBtn.disabled = true;
      }
    }

    uploadBtn.addEventListener('click', async () => {
    if (!uploadBtn.classList.contains('enabled') || uploadBtn.classList.contains('uploading')) return;

    uploadBtn.textContent = 'UPLOADING...';
    uploadBtn.classList.remove('enabled');
    uploadBtn.classList.add('uploading');
    uploadBtn.disabled = true;

    setTimeout(() => {
      uploadBtn.textContent = 'UPLOADED!';
      uploadBtn.classList.remove('uploading');
    }, 3000);
  });
  </script>
</body>
</html>
